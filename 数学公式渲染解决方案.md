# 数学公式渲染解决方案

## 问题分析

当前前端显示的数学题目包含LaTeX格式的代码（如 `$f(x) = \frac{\sqrt{2-x}}{\ln(x+1)}$`），这些代码需要被渲染成可读的数学公式。

### 当前问题位置

1. **QuizComponent.tsx** (答题组件)
   - 第130行：`{currentQuestion.question}` - 题目显示
   - 第144行：`{currentQuestion.options[option]}` - 选项显示

2. **ReportView.tsx** (报告查看组件)
   - 第34行：`{question.question}` - 题目显示
   - 第64行：`{question.options[option]}` - 选项显示
   - 第78行：`{question.explanation}` - 解析显示

### LaTeX格式示例

从图片中可以看到的LaTeX格式：
- `$f(x) = \frac{\sqrt{2-x}}{\ln(x+1)}$` - 函数表达式
- `(-1, 0) \cup (0, 2]$` - 区间表示
- `\frac` - 分数
- `\sqrt` - 根号
- `\ln` - 自然对数
- `\cup` - 并集符号

## 解决方案

### 方案选择：使用 KaTeX

**推荐使用 KaTeX**，原因：
1. ✅ 轻量级，性能好
2. ✅ 渲染速度快
3. ✅ 支持大部分LaTeX语法
4. ✅ 有React集成库 `react-katex`

### 实现步骤

#### 1. 安装依赖

```bash
npm install katex react-katex
npm install --save-dev @types/katex
```

#### 2. 在全局布局中引入KaTeX样式

在 `app/layout.tsx` 中添加：
```typescript
import 'katex/dist/katex.min.css';
```

#### 3. 创建数学公式渲染工具函数

创建 `lib/math-render.tsx`：
```typescript
import { InlineMath, BlockMath } from 'react-katex';
import 'katex/dist/katex.min.css';

// 将文本中的LaTeX代码转换为可渲染的组件
export function renderMath(text: string) {
  // 匹配 $...$ (行内公式) 和 $$...$$ (块级公式)
  const parts: (string | JSX.Element)[] = [];
  let lastIndex = 0;
  let key = 0;

  // 先处理块级公式 $$...$$
  const blockRegex = /\$\$([\s\S]*?)\$\$/g;
  let match;
  const blockMatches: Array<{start: number, end: number, content: string}> = [];
  
  while ((match = blockRegex.exec(text)) !== null) {
    blockMatches.push({
      start: match.index,
      end: match.index + match[0].length,
      content: match[1]
    });
  }

  // 处理行内公式 $...$（排除块级公式内的）
  const inlineRegex = /\$([^$\n]+?)\$/g;
  const inlineMatches: Array<{start: number, end: number, content: string, isBlock: boolean}> = [];
  
  // 添加块级公式
  blockMatches.forEach(bm => {
    inlineMatches.push({
      start: bm.start,
      end: bm.end,
      content: bm.content,
      isBlock: true
    });
  });

  // 添加行内公式（排除在块级公式内的）
  while ((match = inlineRegex.exec(text)) !== null) {
    const isInsideBlock = blockMatches.some(bm => 
      match.index >= bm.start && match.index < bm.end
    );
    if (!isInsideBlock) {
      inlineMatches.push({
        start: match.index,
        end: match.index + match[0].length,
        content: match[1],
        isBlock: false
      });
    }
  }

  // 按位置排序
  inlineMatches.sort((a, b) => a.start - b.start);

  // 构建结果
  inlineMatches.forEach(match => {
    // 添加之前的文本
    if (match.start > lastIndex) {
      parts.push(text.substring(lastIndex, match.start));
    }
    
    // 添加数学公式
    if (match.isBlock) {
      parts.push(<BlockMath key={key++} math={match.content} />);
    } else {
      parts.push(<InlineMath key={key++} math={match.content} />);
    }
    
    lastIndex = match.end;
  });

  // 添加剩余文本
  if (lastIndex < text.length) {
    parts.push(text.substring(lastIndex));
  }

  return parts.length > 0 ? parts : [text];
}
```

#### 4. 修改 QuizComponent.tsx

```typescript
import { renderMath } from '@/lib/math-render';

// 在显示题目和选项的地方使用：
<h3 className="text-xl font-bold text-white mb-6">
  {renderMath(currentQuestion.question)}
</h3>

// 选项
<span className="font-bold text-blue-400 mr-2">{option}.</span>
{renderMath(currentQuestion.options[option])}
```

#### 5. 修改 ReportView.tsx

```typescript
import { renderMath } from '@/lib/math-render';

// 题目
<h3 className="text-lg font-bold text-white flex-1">
  第 {index + 1} 题: {renderMath(question.question)}
</h3>

// 选项
<span className="font-bold mr-2">{option}.</span>
{renderMath(question.options[option])}

// 解析
<p className="text-gray-300">{renderMath(question.explanation)}</p>
```

### 替代方案：使用 MathJax

如果KaTeX不支持某些LaTeX语法，可以使用MathJax：

```bash
npm install react-mathjax2
```

但MathJax更重，加载较慢。

## 注意事项

1. **性能优化**：KaTeX渲染很快，但如果题目很多，可以考虑懒加载
2. **错误处理**：如果LaTeX语法错误，KaTeX会显示错误信息，需要处理
3. **样式调整**：KaTeX的默认样式可能需要调整以匹配网站主题
4. **兼容性**：确保KaTeX支持Deepseek返回的所有LaTeX语法

## 预期效果

修复后，LaTeX代码如：
- `$f(x) = \frac{\sqrt{2-x}}{\ln(x+1)}$` 
- `(-1, 0) \cup (0, 2]$`

将被渲染为：
- 正常的数学公式显示（分数、根号、对数等）
- 可读的数学符号（并集、区间等）

## 实施优先级

**高优先级** - 这直接影响用户体验，数学题目必须可读。
